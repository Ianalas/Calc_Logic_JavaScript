const operators=['∨','&','⇒','⊻','⇔','¬'];

module.exports = {
  evaluateLogic: function (premises,conclusion) {
    if(premises.length<1&&Array.isArray(premises)) return "ERROR: You need at least one premise";
    if(conclusion.length<1&&Array.isArray(conclusion))return "ERROR: Your conclusion cannot be blank";
    return evalLogic(formatPremises(premises),formatConclusion(conclusion));
  }
}

function evalLogic(premises,conclusion) {
  //init vars (orders variables by length so you don't get errors with repetition)
  let variables = getVars(premises,conclusion).sort(function(a,b){return b.length-a.length;});
  let mPremises=premises;
  mPremises.push(conclusion);
  let mConclusion=conclusion;

  for(i=0;i<Math.pow(2,variables.length);i++){
    let initBinary=convertBase(i.toString(),10,2).toString();
    let helper="";
    for(n=0;n<variables.length-initBinary.length;n++){
      helper+="0";
    }
    initBinary=(helper+initBinary).toString().split("");
    let row=[];
    let allOnes=true;
    for(n=0;n<mPremises.length;n++){
      let helperThing=mPremises[n];
      for(p=0;p<variables.length;p++){
        helperThing=helperThing.replace(new RegExp(variables[p],'g'),initBinary[p]);
      }
      while(getOperator(helperThing)!=null){
        helperThing=helperThing.replace(new RegExp('¬0','g'),'1').replace(new RegExp('¬1','g'),'0').replace(new RegExp('\\(0\\)','g'),'0').replace(new RegExp('\\(1\\)','g'),'1');
        const matches = helperThing.match(new RegExp('[0,1][∨,&,⇒,⊻,⇔,¬][0,1]','g'));
        if(matches!=null){
          for(match of matches){
            helperThing=helperThing.replace(match,determineTruth(match));
          }
        }
      }
      if(helperThing=="0"&&n!=mPremises.length-1){
        allOnes=false;
      }
      row.push(helperThing);
    }
    if(allOnes&&row[row.length-1]=="0"){
      return "Argumento inválido"
    }
  }
  return "Argumento válido"
}

function getOperator(str){
  for(operator of operators){
    if(str.includes(operator)){
      return operator;
    }
  }
  return null;
}

function convertBase(value, from_base, to_base) {
  var range = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/'.split('');
  var from_range = range.slice(0, from_base);
  var to_range = range.slice(0, to_base);

  var dec_value = value.split('').reverse().reduce(function (carry, digit, index) {
    if (from_range.indexOf(digit) === -1) throw new Error('Invalid digit `'+digit+'` for base '+from_base+'.');
    return carry += from_range.indexOf(digit) * (Math.pow(from_base, index));
  }, 0);

  var new_value = '';
  while (dec_value > 0) {
    new_value = to_range[dec_value % to_base] + new_value;
    dec_value = (dec_value - (dec_value % to_base)) / to_base;
  }
  return new_value || '0';
}

function getVars(premises,conclusion){
  let variables = [];
  for(premise of premises){
    const match=premise.match(/[^()⇔⊻⇒&∨¬ ]+/g);
    for(matchI of match){
      if(!variables.includes(matchI)){
        variables.push(matchI);
      }
    }
  }
  const matches=conclusion.match(/[^()⇔⊻⇒&∨¬ ]+/g);
  for(match of matches){
    if(!variables.includes(match)){
      variables.push(match);
    }
  }
  return variables;
}

function getPossibilities(variables){
  var possibilities=[];
  const iterations=Math.pow(2,variables.length);
  var helper2=[];
  for(variable of variables){
    helper2.push(0)
  }
  for(p=0;p<iterations;p++){
    var helper=[];
    for(n=0;n<variables.length;n++){
      if(p%Math.pow(2,n)==0){
        if(helper2[n]==0){
          helper2[n]=1;
        }else{
          helper2[n]=0;
        }
      }
      if(helper2[n]==1){
        helper.push(1);
      }else{
        helper.push(0);
      }
    }
    possibilities.push(helper);
  }
  return possibilities;
}

function generateBinary(n){
  if (n<=0){
    return;
  }
  let arr=[];
  arr.push("0");
  arr.push("1");
  for(i=2;i<(1<<n);i=i<<1){
    for(j=i-1;j>=0;j--){
      arr.push(arr[j]);
    }
    for(j=0;j<i;j++){
      arr[j]="0"+arr[j];
    }
    for(j=i;j<i*2;j++){
      arr[j]="1"+arr[j];
    }
  }
  return arr;
}

function formatPremises(premises){
  var tempArray=[];
  for(premise of premises){
    var tempPremise=premise;
    tempPremise=tempPremise.replace(/\s/g,'');
    tempPremise=tempPremise.replace(new RegExp('-->','g'),'⇒');
    tempPremise=tempPremise.replace(new RegExp('<->','g'),'⇔');
    tempPremise=tempPremise.replace(new RegExp('-','g'),'¬');
    tempPremise=tempPremise.replace(new RegExp('>','g'),'⇒');
    tempPremise=tempPremise.replace(new RegExp('\\|!\\|','g'),'⊻');
    tempPremise=tempPremise.replace(new RegExp('\\|','g'),'∨');
    tempPremise=tempPremise.replace(new RegExp('!','g'),'¬');
    tempPremise=tempPremise.replace(new RegExp('¬¬','g'),'');
    tempArray.push(removeExtras(tempPremise));
  }
  return tempArray;
}

function formatConclusion(conclusion){
  let tempConclusion=conclusion.replace(/\s/g,'');
  tempConclusion=tempConclusion.replace(new RegExp('-->','g'),'⇒');
  tempConclusion=tempConclusion.replace(new RegExp('-->','g'),'⇒');
  tempConclusion=tempConclusion.replace(new RegExp('<->','g'),'⇔');
  tempConclusion=tempConclusion.replace(new RegExp('-','g'),'¬');
  tempConclusion=tempConclusion.replace(new RegExp('>','g'),'⇒');
  tempConclusion=tempConclusion.replace(new RegExp('\\|!\\|','g'),'⊻');
  tempConclusion=tempConclusion.replace(new RegExp('\\|','g'),'∨');
  tempConclusion=tempConclusion.replace(new RegExp('!','g'),'¬');
  tempConclusion=tempConclusion.replace(new RegExp('¬¬','g'),'');
  return removeExtras(tempConclusion);
}

function removeExtras(str){
  var pairs=[];
  const pato=getIndices(str,"(");
  for(i=0;i<pato.length;i++){
    pairs.push([pato[i],findClosingBracketMatchIndex(str,pato[i])]);
  }
  var helper='';
  for(pair of pairs){
    if(pair[0]==0&&pair[1]==str.length-1){
      helper='pato';
    }
  }
  if(helper=='pato'){
    return removeExtras(removeAtIndices(str,[0,str.length-1]));
  }else{
    return str;
  }
}

function getIndices(str,char){
  var helper=[];
  for(i=0;i<str.length;i++){
    if(str[i]==char){
      helper.push(i);
    }
  }
  return helper;
}

function removeAtIndices(str,indices){
  var helper=[];
  for(i=0;i<str.length;i++){
    if(!indices.includes(i)){
      helper.push(str[i]);
    }
  }
  return helper.join('');
}

function findClosingBracketMatchIndex(str, pos) {
  if (str[pos] != '(') {
    throw new Error("No '(' at index " + pos);
  }
  let depth = 1;
  for (let i = pos + 1; i < str.length; i++) {
    switch (str[i]) {
    case '(':
      depth++;
      break;
    case ')':
      if (--depth == 0) {
        return i;
      }
      break;
    }
  }
  return -1;
}

function determineTruth(str){
  const mOperator=getOperator(str);
  const fVal=str.split(mOperator)[0];
  const sVal=str.split(mOperator)[1];
  if(mOperator=="⇒"){
    if(fVal=="1"&&sVal=="0"){
      return '0';
    }
    return '1';
  }else if(mOperator=="&"){
    if(fVal=="0"||sVal=="0"){
      return '0';
    }
    return '1';
  }else if(mOperator=="∨"){
    if(fVal=="1"||sVal=="1"){
      return '1';
    }
    return '0';
  }else if(mOperator=="⊻"){
    if(fVal=="1"&&sVal=="0"){
      return '1';
    }
    if(fVal=="0"&&sVal=="1"){
      return '1';
    }
    return '0';
  }else if(mOperator=="⇔"){
    if(fVal=="1"&&sVal=="1"){
      return '1';
    }
    if(fVal=="0"&&sVal=="0"){
      return '1';
    }
    return '0';
  }else if(mOperator=="¬"){
    return str;
  }
}